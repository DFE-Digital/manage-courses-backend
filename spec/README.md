# Testing styleguide

We use ["Futurelearn style" acceptance tests](https://about.futurelearn.com/blog/how-we-write-readable-feature-tests-with-rspec). This style was originally from [the "apply" team's spec docs](https://github.com/DFE-Digital/apply-for-postgraduate-teacher-training/blob/ba9125e9aa5f212c18b63c7c3d49f8785486df83/docs/testing-styleguide.md)

This style guide is newer than the codebase, so you will see a lot of `let` statements around. Use the boy-scout rule and update the style as you touch things.

## Rules

1. Use a single scenario per file. This prevents the files from becoming too large. Separate logical blocks of steps with newlines.
2. Use instance variable to carry state between steps. Don't use `let` or `before` blocks.
3. Define all steps in the file. If you want to share code between scenarios, call helpers that are defined in a module from the step.
4. The steps should be written in English. Don't use parameters to call the step methods.  

## Examples

A good test looks like this:

```rb
# do_a_thing_feature_spec.rb
RSpec.feature 'Do a thing feature' do
  include TestHelpers

  scenario 'User does a thing' do
    given_i_am_signed_in
    when_i_press_a_button
    then_something_should_happen
  end

  def given_i_am_signed_in
    @user = create(:user)
    sign_in(@user)
  end

  def when_i_press_a_button
    click_button 'Do the thing'
  end

  def then_something_should_happen
    expect(@user).to have(done_something)
  end
end

# helpers.rb
module TestHelpers
  def sign_in(user)
    # do the thing
  end
end
```

A less good test looks like this:

```rb
# do_a_thing_feature_spec.rb
RSpec.feature 'Do a thing feature' do
  include TestHelpers

  let(:user) { create(:user) } # Bad: a `let` block adds noise to the file and adds indirection

  # Bad: a `before` block adds noise to the file and can make it unclear why something is set up
  before do
    sign_in_user(user)
  end

  scenario 'User does a thing' do
    when_i_press_a_button('Do the thing') # Bad: a parameterised method makes the step harder to read
    then_something_should_happen # Bad: hidden in a module
  end

  # Bad: multiple scenarios clutter the file and slow down the test suite
  scenario 'User does a different thing' do
    when_i_press_a_button('Do the thing') # Bad: a parameterised method makes the step harder to read
    then_something_else_should_happen # Bad: hidden in a module
  end

  # Bad: a parameterised method
  def when_i_press_a_button(text)
    click_button(text)
  end

  def then_something_else_should_happen
    expect(@user).to have(done_something_else)
  end
end

# helpers.rb
module TestHelpers
  def then_something_should_happen
    expect(@user).to have(done_something)
  end
end
```

## Why not `let`

* https://thoughtbot.com/blog/lets-not
* https://thoughtbot.com/blog/my-issues-with-let


# Using Factories

We are using
[factory_bot_rails](https://github.com/thoughtbot/factory_bot_rails#factory_bot_rails----)
to generate valid graphs of objects for testing.

This readme documents our chosen pattern for using them and creating them.

* `build()` builds the object(s) in memory only
* `create()` builds the object(s) in memory and saves it to the database

## Creation

To create a course, its provider and any other objects needed to create a valid
course and save it to the database (obeying nullability and foreign key rules):

```
def when_a_course_exists  { create :course }
```

## Finding generated related objects

To get the provider implicitly generated by the course factory:

```
def when_a_course_exists  { create :course }
def provider { course.provider }
```

## Overriding the creation of a dependent object

```
def when_a_course_exists  { create :course, subjects: [english_subject] }
def english_subject { create :subject, :english }
```

When creating associated data, keep in mind which object is the `belongs_to`
side. The object that has the `belongs_to` association should be the one that
associates the two objects.

```
# CORRECT
def provider { create :provider }
def when_a_course_exists   { create :course, provider: provider }
# CORRECT
```

```
# WRONG
def when_a_course_exists   { create :course }
def provider { create :provider, courses: [course] }
# WRONG
```

If done wrong (second) way, then two providers will be created in the DB, one as the
memoized provider and second as part of the `create :course`.

## Singletons

* Use find_or_create for objects that should be singletons (e.g. "English"
  subject)


# Creating Factories

The way we do it:

1. Created objects should be valid by default, so ensure that required
   associations are built/created.
2. Avoid building/creating associations that aren't necessary. (i.e. nullable
   foreign keys, and many-to-many relationships with join tables).
3. Provide a way to overide associated objects, for has_* relationships this
   will need to build associated objects by default, and add them to the parent
   object in an `after_create` hook.
4. Provide a way to specify exactly what associated object(s) override.
5. When creating a memoized object that is included in the creation of another
   object, use `build` to prevent secondary objects from being created.
6. Factories can be tested too, e.g.
   <https://github.com/DFE-Digital/teacher-training-api/blob/master/spec/factory_specs/course_spec.rb>
7. Don't continue the `count` trait pattern you might find already in the code
   for creating many related objects, that turned out not to be such a great
   idea. Help eliminate them if you can.
